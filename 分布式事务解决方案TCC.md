### TCC

##### 简单介绍

###### 目的：解决跨库操作的数据一致性问题。

###### TCC实现思想：

```
将服务过程划分为两个编程阶段，主要由Try,Confirm,Cannel 3个方法构成。
第一阶段由Try方法实现，主要负责资源的检查和预留。
第二阶段由Confirm或者Cannel组成，当第一阶段确认资源时，提交Confirm操作，执行真正的业务；若第一阶段未得到确认或者没有执行时，则提交Cannel操作，取消资源的预留。
```

##### 实现注意事项

###### 业务操作分两段

```
	接入TCC前，业务操作只需要一步就能完成，但是在接入TCC之后，需要考虑如何将其分成2阶段完成，把资源的检查和预留放在一阶段的Try操作中进行，把真正的业务操作的执行放在二阶段的Confirm操作中进行；
	TCC服务要保证第一阶段Try操作成功之后，二阶段Confirm操作一定能成功；
```

###### 允许空回滚

```
	TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行；
```

###### 防悬挂控制

```
	事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况；
	用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求；
```

###### 幂等控制

```
	无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行；用户在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行次和执行多次的业务结果是一样的；
```

业务数据可见性控制

```
	TCC服务的一阶段Try操作会做资源的预留，在二阶段操作执行之前，如果其他事务需要读取被预留的资源数据，那么处于中间状态的业务数据该如何向用户展示，需要业务在实现时考虑清楚；通常的设计原则是“宁可不展示、少展示，也不多展示、错展示”；
```

业务数据并发访问控制

```
	TCC服务的一阶段Try操作预留资源之后，在二阶段操作执行之前，预留的资源都不会被释放；如果此时其他分布式事务修改这些业务资源，会出现分布式事务的并发问题；
	用户在实现TCC服务时，需要考虑业务数据的并发控制，尽量将逻辑锁粒度降到最低，以最大限度的提高分布式事务的并发性；
```

